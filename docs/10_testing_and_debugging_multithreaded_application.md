## 동시성 관련 버그의 유형
  
* 동시성과 직접적으로 관련된 버그는 크게 의도하지 않은 차단과 경쟁 조건의 두 가지 범주로 나눌 수 있다.
* 의도하지 않은 블로킹에는 다음과 같은 상황이 포함된다.
  * 교착 상태: 두 개의 스레드가 서로 대기 중이어서 어느 쪽도 작업을 완료할 수 없는 상태이다. 가장 명백한 경우로 사용자 인터페이스를 담당하는 스레드가 교착 상태에 빠지면 인터페이스가 응답하지 않는다. 인터페이스는 계속 응답하지만 결과를 반환하지 않는 검색이나 인쇄되지 않는 문서와 같이 일부 작업을 완료할 수 없는 경우도 있다.
  * 라이브락: 교착 상태와 비슷하지만 차단 대신 스핀락과 같은 확인 루프에서 스레드가 사용 중이라는 점이 다르다. 심한 경우에는 프로그램이 진행되지 않고 스레드가 계속 실행 중이기 때문에 CPU 사용률이 높은 상태가 되는 등 교착 상태와 증상이 동일하다. 덜 심각한 경우 라이브 락은 운영 체제의 임의 스케줄링에 의해 결국 해결되지만, 여전히 작업이 오래 지연되고 지연되는 동안 CPU 사용률이 높아진다.  
  * I/O 차단 또는 기타 외부 입력: 스레드가 외부 입력을 기다리다가 차단되면 작업을 계속 처리할 수 없다. 따라서 실행 중인 작업이 다른 스레드에서 대기 중인 경우 스레드가 외부 입력을 대기하지 않도록 한다.
* 작업 대기열의 다음 작업을 처리해야 하는 경우와 같이 대부분의 경합 조건이 양성인 경우 교착 상태와 교착 상태가 많이 발생하지만, 이를 위해 어떤 작업자 스레드를 사용할지 결정하는 것은 관련이 없다. 문제를 일으키는 경쟁 조건에는 다음과 같은 상황이 포함된다.
  * 데이터 레이스: 데이터 레이스는 공유 메모리 위치에 대한 비동기 동시 액세스로 인해 정의되지 않은 동작을 초래하는 특정 유형의 레이스 조건이다. 데이터 레이스는 일반적으로 스레드가 원자 연산을 사용하여 잘못 동기화되거나 공유 데이터가 잠금 없이 액세스될 때 발생한다.
  * 깨진 불변성: 널 댕글링 포인터(다른 스레드가 액세스 중인 데이터를 삭제할 수 있는 경우), 무작위 메모리 손상(로컬 업데이트로 인해 스레드가 일관되지 않은 값을 읽는 경우), 이중 해제(예를 들어 두 스레드가 큐에서 동일한 데이터를 꺼내는 경우) 등으로 나타날 수 있다. 불변성 손상은 값 기반이기 때문에 일시적이다. 서로 다른 스레드의 작업이 특정 순서로 실행되어야 하는 경우, 잘못된 동기화로 인해 이 실행 순서를 위반하는 경쟁 조건이 발생할 수 있다.
  * 수명 문제: 이 문제는 깨진 불변성 아래에 포함될 수 있지만 여기서는 별도로 설명한다. 이 문제는 스레드가 액세스하는 데이터보다 오래 지속될 때 발생한다. 일반적으로 이 문제는 스레드가 범위를 벗어난 로컬 변수를 참조할 때 발생하지만, 예외가 발생할 때 호출이 건너뛰지 않는다는 점을 고려하면 [join](https://en.cppreference.com/w/cpp/thread/thread/join) 호출에 국한되지 않는다.
* 교착 상태 및 라이브 잠금 상태의 스레드와 이들이 경합하는 동기화 객체는 일반적으로 디버거로 식별할 수 있다. 데이터 경합, 불변성 손상, 수명 주기 문제의 경우 눈에 보이는 증상(예: 무작위 충돌 또는 잘못된 출력)이 코드의 어느 곳에서나 나타날 수 있으며, 코드가 시스템의 다른 부분에서 사용하는 메모리를 다시 작성하여 훨씬 늦게까지 건드리지 않을 수 있고, 버그가 발생한 코드와 전혀 관련이 없는 위치에서 프로그램 실행 후반에 버그가 나타날 수도 있다. 아무리 스레드 액세스를 제한하고 적절한 동기화를 보장하더라도 모든 스레드가 다른 스레드의 데이터를 다시 쓸 수 있다는 것이 공유 메모리의 진정한 문제이다!  
    
## 버그 찾기  
  
### code review
  
* 코드에 익숙하지 않다면 코드가 어떻게 작동하는지 생각해보고 다른 관점에서 바라볼 필요가 있으며 잠재적인 문제를 발견할 가능성이 높으므로 잠시 후 다른 사람이나 자신에게 코드 검토를 맡기자. 멀티 스레드 코드에는 일반적으로 다음과 같은 문제가 있다.
  * 동시 액세스로부터 보호해야 하는 데이터의 종류
  * 데이터를 보호하는 방법
  * 현재 코드에서 다른 스레드가 실행되고 있을 수 있는 위치
  * 이 스레드가 보유하고 있는 잠금
  * 다른 스레드에서 어떤 잠금을 보유하고 있는지
  * 이 스레드에서 수행된 작업과 다른 스레드에서 수행된 작업 간에 순서 요구 사항이 있는지 여부 및 해당 요구 사항을 적용하는 방법
  * 이 스레드에서 읽은 데이터가 여전히 유효한지 여부 및 다른 스레드에 의해 수정되었을 수 있는지 여부
  * 다른 스레드가 데이터를 수정하고 있다고 가정할 때, 이는 무엇을 의미하며 어떻게 이런 일이 발생하지 않도록 보장할 수 있는가?
     
  
### 테스트
  
* 멀티 스레드 프로그램을 테스트할 때 어려운 점은 스레드가 예약되는 정확한 순서가 불확실하고 동일한 입력에 대해 결과가 항상 같지 않을 수 있으며, 때로는 결과가 맞을 수도 있고 때로는 틀릴 수도 있다는 것이다. 따라서 잠재적인 경합 조건이 존재한다고 해서 항상 실패한 결과를 얻을 수 있는 것은 아니며, 때로는 성공할 수도 있다.
* 동시성 관련 버그는 재현하기 어렵기 때문에 테스트를 신중하게 설계하는 것이 좋다. 테스트가 실패할 경우 잘못된 코드를 가장 잘 분리할 수 있도록 각 테스트에서 최소한의 코드를 실행하도록 하는 것이 좋다. 예를 들어, 동시 대기열을 테스트하고 동시 push 및 pop 작업을 개별적으로 테스트하는 것이 전체 대기열의 기능을 테스트하는 것보다 직접적으로 더 낫다.
* 문제가 동시성 관련 문제인지 확인하려면 테스트에서 동시성을 제거해야 한다. 멀티스레딩 버그가 반드시 동시성 관련 버그인 것은 아니다. 문제가 항상 단일 스레드에서 나타나는 경우 동시성 관련 버그가 아닌 일반적인 버그이다. 문제가 단일 코어 시스템에서는 사라지고 멀티코어 또는 다중 프로세서 시스템에서 항상 나타나는 경우 일반적으로 경쟁 조건 또는 동기화 또는 메모리 순서 관련 문제일 수 있다.
* 테스트 사례
  * 단일 스레드에서 push() 또는 pop()을 호출하여 기본 queue 기능을 확인하는 경우.
  * 빈 queue, 하나의 스레드 push(), 다른 스레드 pop().
  * 빈 queue, 다중 스레드 push()
  * 전체 queue, 다중 스레드 push()
  * 빈 queue, 멀티스레드 pop()
  * 전체 queue, 멀티스레드 pop()
  * 일부 데이터가 있지만 모든 스레드에 충분하지 않은 queue, 멀티스레드 pop()
  * 빈 queue, 1 스레드 pop(), 멀티스레드 push()
  * 전체 queue, 하나의 스레드 pop(), 여러 스레드 push()
  * 빈 queue, 다중 스레드 pop(), 다중 스레드 push() * 전체 queue, 단일 스레드 pop(), 다중 스레드 push()
  * 전체 queue, 다중 스레드 pop(), 다중 스레드 push()
* 테스트 환경
  * 각 경우에서 멀티스레딩은 몇 개의 스레드를 의미합니까(3, 4, 1,024?) * 멀티스레딩은 각 경우에서 몇 개의 스레드를 의미합니까?
  * 각 스레드가 자체 코어에서 실행하기에 충분한 프로세서가 있는지 여부.
  * 테스트할 프로세서 아키텍처
  * 테스트의 동안 부분에 대한 적절한 스케줄링 방법.
* 단일 스레드 코드와 멀티 스레드 코드에 동일하게 적용되는 다음 조건을 충족하는 코드는 일반적으로 테스트하기 쉽다.
  * 각 함수와 클래스의 책임이 명확하다.
  * 함수가 짧고 요점이 명확하다.
  * 테스트 대상 코드가 상주하는 환경을 완전히 제어할 수 있다.
  * 특정 동작을 수행하는 테스트 대상 코드가 분산되어 있지 않고 시스템 내에 밀집되어 있다.
  * 코드가 작성되기 전에 테스트 대상으로 고려됨
* 테스트를 위한 동시 코드를 설계하는 가장 좋은 방법 중 하나는 동시성을 제거하는 것이다. 코드를 스레드 간 통신 경로를 담당하는 부분과 단일 스레드에서 통신 데이터를 조작하는 부분으로 나눌 수 있다면 문제를 크게 단순화할 수 있다. 통신 데이터를 조작하는 부분은 일반적인 단일 스레드 기술을 사용하여 테스트할 수 있고, 스레드 간 통신을 담당하는 부분은 코드가 훨씬 작아지고 테스트하기 쉬워진다.  
    
  
### 멀티 스레드 테스트 기법
  
* 첫 번째 테스트 기법은 스트레스 테스트이다. 코드가 실행되는 횟수가 증가할수록 버그가 나타날 확률이 높아지며, 코드가 10억 번을 통과하면 정상일 가능성이 높다. 스트레스 테스트는 앞서 동시 대기열 테스트에서와 같이 테스트가 세분화되어 있는 경우 더 신뢰할 수 있다. 세분성이 매우 크고 가능한 조합의 수가 매우 많으면 10억 번의 테스트 결과도 신뢰할 수 있는 것으로 간주되지 않는다.
* 스트레스 테스트의 단점은 테스트가 문제가 발생하지 않는다고 보장해야 하는 경우 테스트를 아무리 많이 실행해도 실패하지 않아 오해의 소지가 있을 수 있다는 것이다. 예를 들어 싱글 코어 시스템에서 멀티스레드 프로그램을 테스트하면 경쟁 조건과 핑퐁 캐싱 문제가 전혀 발생하지 않지만, 그렇다고 해서 멀티코어 시스템에서 프로그램이 정상적으로 작동한다는 의미는 아니다. 또 다른 예로, 프로세서 아키텍처마다 다른 동기화 및 메모리 순서 지정 도구를 제공하며 x86 및 x86-64 아키텍처에서는 [memory_order_relaxed](https://en.cppreference.com/w/cpp/atomic/memory_order) 또는 [[메모리 순서 지정]](https://en.cppreference.com/w/cpp/atomic/memory_order)를 사용할 필요가 없다. [memory_order_seq_cst](https://en.cppreference.com/w/cpp/atomic/memory_order) 메모리 순서에서 원자 로드 연산은 항상 동일하므로 x86 아키텍처에서는 항상 완화된 의미론을 사용할 수 있지만 세분화된 메모리 순서 명령어(예: SPARC)가 있는 시스템으로 전환하면 실패한다.  
* 두 번째 테스트 기법은 조합 시뮬레이션 테스트로 특수 소프트웨어를 사용하여 실제 런타임 환경을 시뮬레이션하는 것이다. 이 시뮬레이션 소프트웨어는 데이터 액세스, 잠금 및 원자 연산 시퀀스를 기록한 다음 C++ 메모리 모델의 규칙을 사용하여 가능한 모든 연산 조합을 반복적으로 실행하여 경쟁 조건과 교착 상태를 확인한다.  
* 이 철저한 조합 테스트는 설계가 감지하도록 설계된 모든 문제를 찾을 수 있지만 스레드 수와 각 스레드가 수행하는 작업 수에 따라 조합의 수가 기하급수적으로 증가하기 때문에 시간이 많이 걸릴 수 있으며 전체 프로그램보다는 개별 코드 조각을 세밀하게 테스트하는 데 가장 적합한다. 이 기법의 또 다른 명백한 단점은 코드의 연산을 처리할 수 있는 충실도 소프트웨어가 필요하다는 것이다.
* 세 번째 테스트 기법은 특수 라이브러리를 사용하는 것이다. 예를 들어 공유 데이터는 뮤텍스로 보호되는 경우가 많은데 데이터에 액세스할 때 어떤 뮤텍스가 잠겨 있는지 확인할 수 있다면 스레드가 데이터에 액세스할 때 해당 뮤텍스를 잠갔는지 확인하고 그렇지 않은 경우 실패를 보고할 수 있다. 라이브러리 구현은 잠금이 적용되는 순서도 기록할 수 있으므로 다른 스레드가 동일한 뮤텍스를 다른 순서로 잠그면 잠재적 교착 상태로 기록된다.
* 또 다른 유형의 라이브러리는 동기화 프리미티브의 구현을 통해 테스트 작성자가 여러 스레드에서 대기하는 동안 어떤 스레드가 잠금을 획득할지, 또는 어떤 스레드가 [notify_one](https://en.cppreference.com/w/cpp/thread/condition_variable/ notify_one) 알림을 받을 스레드를 제어할 수 있다. 이를 통해 특정 시나리오를 설정하여 해당 시나리오에서 코드가 예상대로 작동하는지 확인할 수 있다.
* 일부 테스트 도구는 표준 라이브러리 구현의 일부로 이미 제공되며 다른 테스트 도구는 표준 라이브러리의 일부를 기반으로 수동으로 구현할 수 있다.  
  

### 멀티 스레드 테스트 코드 빌드하기

* 멀티 스레드 테스트 코드는 다음과 같은 섹션으로 나눌 수 있다.
    * 먼저 실행해야 하는 전체 설정
    * 각 스레드에서 실행해야 하는 스레드별 설정
    * 각 스레드에서 동시에 실행할 코드
    * 동시 실행이 끝날 때의 상태 어설션
    * 다음은 큐에 대한 테스트 코드이다
  
```cpp
void test_concurrent_push_and_pop_on_empty_queue() {
  ConcurrentQueue<int> q;  // 전체 설정: 먼저 큐 만들기
  std::promise<void> go, push_ready, pop_ready;
  std::shared_future<void> ready(go.get_future());
  std::future<void> push_done;
  std::future<int> pop_done;
  try {
    push_done = std::async(
        std::launch::async,  // 각 작업이 자체 스레드에서 실행되도록 비동기 전략을 지정한다
        [&q, ready, &push_ready]() {
          push_ready.set_value();
          ready.wait();
          q.push(42);  // 스레드별 설정: int 를 넣는다
        });
    pop_done = std::async(std::launch::async, [&q, ready, &pop_ready]() {
      pop_ready.set_value();
      ready.wait();
      return q.try_pop();
    });
    push_ready.get_future().wait();  // 테스트를 시작할 때까지 기다린다等待开始测试的通知
    pop_ready.get_future().wait();   // 상동
    go.set_value();                  // 실제 테스트 시작을 알린다
    push_done.get();                 // 결과 가져오기
    assert(pop_done.get() == 42);    // 결과 가져오기
    assert(q.empty());
  } catch (...) {
    go.set_value();  // null 포인터를 피한다
    throw;           // 다른 예외를 던진다
  }
}
```

### 멀티스레드 코드 성능 테스트하기

* 동시성을 사용하는 주요 목적 중 하나는 멀티코어 프로세서를 활용하여 프로그램의 성능을 향상시키는 것이므로 실제로 성능이 향상되는지 확인하기 위해 코드를 테스트하는 것이 중요하다. 성능과 관련된 주요 측면 중 하나는 확장성이며, 코어 수에 따라 성능도 함께 향상되어야 한다. 멀티 스레드 코드의 성능을 테스트할 때는 가능한 한 다양한 구성에서 테스트하는 것이 가장 좋다.  